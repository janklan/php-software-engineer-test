<?php
namespace SoftwareEngineerTest;

require 'db.php';

/**
 * Class Customer
 * @package SoftwareEngineerTest
 */
/**
 * Class Customer
 * @package SoftwareEngineerTest
 */
abstract class Customer {

    /**
     * Bronze level identifier (Customer ID must begin with this letter to indicate a bronze level)
     */
    const LEVEL_BRONZE  = 'B';

    /**
     * Silver level identifier (Customer ID must begin with this letter to indicate a silver level)
     */
    const LEVEL_SILVER  = 'S';

    /**
     * Gold level identifier (Customer ID must begin with this letter to indicate a gold level)
     */
    const LEVEL_GOLD    = 'G';

    /**
     * List of known customer levels and their respective user classes
     * @var array
     */
    private static $allowed_levels = array(
        self::LEVEL_BRONZE  => '\SoftwareEngineerTest\Bronze_Customer',
        self::LEVEL_SILVER  => '\SoftwareEngineerTest\Silver_Customer',
        self::LEVEL_GOLD    => '\SoftwareEngineerTest\Gold_Customer',
    );

    /**
	 * @var int Customer ID
     */
	protected $id;

	/**
	 * @var int Current balance
     */
	protected $balance = 0;

    /**
     * @var float Coeficient added the current user level deposits
     */
    protected $bonus_coeficient = 1.0;

	/**
	 * Customer constructor.
	 * @param $id
     */
	public function __construct($id) {
		$this->id = $id;
	}

	/**
	 * Returns the current balance
	 * @return int
     */
	public function get_balance() {
		return $this->balance;
	}

    /**
     * Adds specified $amount to the {@see balance}
     * @param $amount
     * @return Customer
     */
    public function deposit($amount) {
        $this->balance += (float)$amount * $this->get_bonus_coeficient();
        return $this;
    }

    /**
     * Factory method returns the correct customer instance based on the ID specified.
     *
     * @see $allowed_levels
     * @param $id ID in format [A-Z]\d{,9}
     * @return Descendants of the Customer class
     * @throws \InvalidArgumentException
     */
    public static function get_instance($id) {

        // The first character of the ID should be one of our customer levels
        $customerLevel = strtoupper($id[0]);

        if (isset(self::$allowed_levels[$customerLevel])) {
            $customerId = (int)preg_replace('/[^\d]/', '', $id);
            // Spec says ID and number has maxlength(10), so the (int)$id must be <= 999 999 999
            //  and > 0, as 0 would mean invalid ID specified
            if ($customerId > 0 && $customerId <= 999999999) {
                return new self::$allowed_levels[$customerLevel]($customerId);
            } else {
                throw new \InvalidArgumentException('Invalid customer ID specified.');
            }
        } else {
            throw new \InvalidArgumentException('Invalid customer level specified.');
        }
    }

    /**
     * Returns current bonus coeficient.
     *
     * If none is set, returns "1".
     *
     * @return int
     */
    protected function get_bonus_coeficient()
    {
        return $this->bonus_coeficient;
    }

    /**
     * Generates unique username of length between 10 and 30 characters including the initial customer level identifier
     *
     * @return string Unique username
     */
    public function generate_username()
    {
        // Fetch the ID level
        $customerLevelKey = array_search('\\'.get_class($this), self::$allowed_levels);

        try {
            // Fetch the MySQL
            $sql = Database::get_instance();

            do {
                // Generate a string of a total length between 10 and 30 (10 being my own arbitraty number, 30 limit of the database)
                $username = $customerLevelKey.substr(str_shuffle("0123456789abcdefghijklmnopqrstuvwxyz"), 0, rand(9, 29));

                // Load a record if it exists
                $result = $sql->query("SELECT customer_id FROM customer WHERE username = '{$username}'");

            // Rinse and repeat until there are no found rows --> no duplicate user names
            } while ($result->num_rows > 0);

            /**
             * Note: I did not implement any methods to avoid entering infinite loop if all names were taken.
             *
             * First, with this amount of combinations it is unlikely.
             *
             * Second, if there was a high chance of running into existing user names, I would implement a different solution:
             *  free usernames would be generated by a background process, not in the runtime. Everytime we would need any
             *  unique user name, we would just load the first row in that preprocessed table and removed it upon saving to the
             *  customer database (row level locking would have to be put in place).
             */

            return $username;

        } catch(\mysqli_sql_exception $e) {
            die($e->getMessage());
        }
    }
}

/**
 * Class Bronze_Customer
 * @package SoftwareEngineerTest
 */
class Bronze_Customer extends Customer {
    // Void
}

/**
 * Class Silver_Customer
 * @package SoftwareEngineerTest
 */
class Silver_Customer extends Customer {
	/**
	 * Coeficient added the current user level deposits
	 * @var float
     */
	protected $bonus_coeficient = 1.05;
}

/**
 * Class Gold_Customer
 * @package SoftwareEngineerTest
 */
class Gold_Customer extends Customer {
	/**
	 * Coeficient added the current user level deposits
	 * @var float
     */
	protected $bonus_coeficient = 1.1;
}

echo 'Golden balance after 100 deposit: '.Customer::get_instance('G1')->deposit(100)->get_balance();
echo '<br>';

echo 'Silver balance after 100 deposit: '.Customer::get_instance('S2')->deposit(100)->get_balance();
echo '<br>';

echo 'Bronze balance after 100 deposit: '.Customer::get_instance('B3')->deposit(100)->get_balance();
echo '<br>';

echo 'Generated Golden user name: '.Customer::get_instance('G3')->generate_username();

echo '<hr>';

show_source(__FILE__);
